// Load per-video render configuration from render_config.json
// Generated by the audio_sync pipeline (replaces old segmentData.ts approach)

import { staticFile } from "remotion";

export interface RenderScene {
    scene_number: number;
    image_path: string;
    display_start: number;
    display_end: number;
    display_duration: number;
    narration_start: number;
    narration_end: number;
    style: string;
    composition: string;
    act: number;
    ken_burns: Record<string, unknown>;
    transition_in: Record<string, unknown>;
    transition_out: Record<string, unknown>;
    sentence_text?: string;
    image_index?: number;
}

export interface RenderConfig {
    video_id: string;
    audio_path: string;
    total_duration_seconds: number;
    fps: number;
    resolution: {
        width: number;
        height: number;
    };
    scenes: RenderScene[];
}

/**
 * Segment text data derived from render_config scenes.
 * Replaces the old SegmentText interface from segmentData.ts.
 */
export interface SegmentText {
    text: string;
    duration: number;
}

// Module-level cache for loaded render config
let _cachedConfig: RenderConfig | null = null;

/**
 * Load render_config.json from the public/ directory via Remotion's
 * static file server.  Uses a synchronous XMLHttpRequest so the data
 * is available immediately at component-registration time (Root.tsx).
 *
 * Returns null only if the file genuinely doesn't exist.
 */
export function loadRenderConfig(): RenderConfig | null {
    if (_cachedConfig) return _cachedConfig;

    try {
        const url = staticFile("render_config.json");
        const xhr = new XMLHttpRequest();
        xhr.open("GET", url, false); // synchronous
        xhr.send();
        if (xhr.status === 200) {
            const config = JSON.parse(xhr.responseText) as RenderConfig;
            _cachedConfig = config;
            return config;
        }
        return null;
    } catch {
        // render_config.json not present â€” pipeline hasn't generated it yet
        return null;
    }
}

/**
 * Get the number of scenes from render config.
 * Groups render_config scenes by scene_number (multiple images may share a scene).
 */
export function getSceneCount(): number {
    const config = loadRenderConfig();
    if (!config || config.scenes.length === 0) return 0;

    const sceneNumbers = new Set(config.scenes.map((s) => s.scene_number));
    return sceneNumbers.size;
}

/**
 * Get render_config scenes for a specific scene number.
 * Each returned entry represents one image with its display timing.
 */
export function getRenderScenesForScene(sceneNumber: number): RenderScene[] {
    const config = loadRenderConfig();
    if (!config) return [];

    return config.scenes.filter((s) => s.scene_number === sceneNumber);
}

/**
 * Get image count for a scene from render config.
 */
export function getImageCountForScene(sceneNumber: number): number {
    return getRenderScenesForScene(sceneNumber).length;
}

/**
 * Get scene duration from render_config (sum of per-image display_duration).
 * Returns null if render_config is unavailable or has no entries for this scene.
 */
export function getSceneDurationFromConfig(sceneNumber: number): number | null {
    const scenes = getRenderScenesForScene(sceneNumber);
    if (scenes.length === 0) return null;
    const total = scenes.reduce((sum, s) => sum + s.display_duration, 0);
    return total > 0 ? total : null;
}

/**
 * Get total video duration from render_config.
 * Returns null if render_config is unavailable.
 */
export function getTotalDurationFromConfig(): number | null {
    const config = loadRenderConfig();
    if (!config || !config.total_duration_seconds) return null;
    return config.total_duration_seconds > 0 ? config.total_duration_seconds : null;
}
