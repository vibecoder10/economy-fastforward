// Load per-video render configuration from render_config.json
// Generated by the audio_sync pipeline (replaces old segmentData.ts approach)

import renderConfigJson from "../public/render_config.json";

export interface RenderScene {
    scene_number: number;
    image_path: string;
    display_start: number;
    display_end: number;
    display_duration: number;
    narration_start: number;
    narration_end: number;
    style: string;
    composition: string;
    act: number;
    ken_burns: Record<string, unknown>;
    transition_in: Record<string, unknown>;
    transition_out: Record<string, unknown>;
    sentence_text?: string;
    image_index?: number;
}

export interface RenderConfig {
    video_id: string;
    audio_path: string;
    total_duration_seconds: number;
    fps: number;
    resolution: {
        width: number;
        height: number;
    };
    scenes: RenderScene[];
}

/**
 * Segment text data derived from render_config scenes.
 * Replaces the old SegmentText interface from segmentData.ts.
 */
export interface SegmentText {
    text: string;
    duration: number;
}

// Module-level cache for loaded render config
let _cachedConfig: RenderConfig | null = null;

/**
 * Load render_config.json via a static import (bundled at build time).
 * This avoids XMLHttpRequest which doesn't exist in Remotion's Node render context.
 *
 * Returns null only if the import somehow fails.
 */
export function loadRenderConfig(): RenderConfig | null {
    if (_cachedConfig) return _cachedConfig;
    try {
        _cachedConfig = renderConfigJson as unknown as RenderConfig;
        return _cachedConfig;
    } catch {
        return null;
    }
}

/**
 * Get the sorted list of unique scene numbers from render config.
 * This is the authoritative list â€” scene numbers may not be sequential
 * (e.g. if audio_sync skipped a scene due to Whisper failure).
 */
export function getSceneNumbers(): number[] {
    const config = loadRenderConfig();
    if (!config || config.scenes.length === 0) return [];

    const nums = new Set(config.scenes.map((s) => s.scene_number));
    return Array.from(nums).sort((a, b) => a - b);
}

/**
 * Get the number of scenes from render config.
 * Groups render_config scenes by scene_number (multiple images may share a scene).
 */
export function getSceneCount(): number {
    return getSceneNumbers().length;
}

/**
 * Get render_config scenes for a specific scene number.
 * Each returned entry represents one image with its display timing.
 */
export function getRenderScenesForScene(sceneNumber: number): RenderScene[] {
    const config = loadRenderConfig();
    if (!config) return [];

    return config.scenes.filter((s) => s.scene_number === sceneNumber);
}

/**
 * Get image count for a scene from render config.
 */
export function getImageCountForScene(sceneNumber: number): number {
    return getRenderScenesForScene(sceneNumber).length;
}

/**
 * Get scene duration from render_config (sum of per-image display_duration).
 * Returns null if render_config is unavailable or has no entries for this scene.
 */
export function getSceneDurationFromConfig(sceneNumber: number): number | null {
    const scenes = getRenderScenesForScene(sceneNumber);
    if (scenes.length === 0) return null;
    const total = scenes.reduce((sum, s) => sum + s.display_duration, 0);
    return total > 0 ? total : null;
}

/**
 * Get total video duration from render_config.
 * Returns null if render_config is unavailable.
 */
export function getTotalDurationFromConfig(): number | null {
    const config = loadRenderConfig();
    if (!config || !config.total_duration_seconds) return null;
    return config.total_duration_seconds > 0 ? config.total_duration_seconds : null;
}
