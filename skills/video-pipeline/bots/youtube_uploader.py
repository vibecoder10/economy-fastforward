"""YouTube Data API v3 uploader for the video pipeline.

Uploads rendered videos to YouTube as unlisted drafts. Ryan manually
publishes after review -- no auto-publish for irreversible actions.

Prerequisites:
    - Google Cloud project with YouTube Data API v3 enabled
    - OAuth2 credentials at skills/video-pipeline/.youtube-credentials.json
    - Token file at skills/video-pipeline/.youtube-token.json
      (generated by running youtube_auth.py once)

Quota:
    YouTube Data API v3 daily quota: 10,000 units
    Video upload cost: 1,600 units (~6 uploads/day)
"""

import os
import tempfile
from pathlib import Path
from typing import Optional

from google.oauth2.credentials import Credentials
from google.auth.transport.requests import Request
from googleapiclient.discovery import build
from googleapiclient.http import MediaFileUpload


# Default paths for credentials (relative to this file's directory)
_PIPELINE_DIR = Path(__file__).parent.parent
CREDENTIALS_FILE = _PIPELINE_DIR / ".youtube-credentials.json"
TOKEN_FILE = _PIPELINE_DIR / ".youtube-token.json"

# YouTube API scopes
SCOPES = ["https://www.googleapis.com/auth/youtube.upload"]

# Default category
DEFAULT_CATEGORY_ID = "27"  # Education


class YouTubeUploader:
    """Uploads videos to YouTube as unlisted drafts."""

    def __init__(
        self,
        credentials_file: Optional[str] = None,
        token_file: Optional[str] = None,
        category_id: Optional[str] = None,
    ):
        self.credentials_file = Path(credentials_file or CREDENTIALS_FILE)
        self.token_file = Path(token_file or TOKEN_FILE)
        self.category_id = category_id or os.getenv(
            "YOUTUBE_CATEGORY_ID", DEFAULT_CATEGORY_ID
        )
        self._service = None

    def _get_credentials(self) -> Credentials:
        """Load or refresh YouTube OAuth2 credentials.

        Returns:
            Valid Credentials object

        Raises:
            FileNotFoundError: If token file doesn't exist (run youtube_auth.py first)
        """
        if not self.token_file.exists():
            raise FileNotFoundError(
                f"YouTube token not found at {self.token_file}. "
                f"Run 'python youtube_auth.py' to complete OAuth flow first."
            )

        import json

        with open(self.token_file) as f:
            token_data = json.load(f)

        creds = Credentials(
            token=token_data.get("token"),
            refresh_token=token_data.get("refresh_token"),
            token_uri=token_data.get("token_uri", "https://oauth2.googleapis.com/token"),
            client_id=token_data.get("client_id"),
            client_secret=token_data.get("client_secret"),
            scopes=SCOPES,
        )

        # Refresh if expired
        if creds.expired and creds.refresh_token:
            creds.refresh(Request())
            # Save refreshed token
            self._save_token(creds)

        return creds

    def _save_token(self, creds: Credentials):
        """Save credentials to token file."""
        import json

        token_data = {
            "token": creds.token,
            "refresh_token": creds.refresh_token,
            "token_uri": creds.token_uri,
            "client_id": creds.client_id,
            "client_secret": creds.client_secret,
        }
        with open(self.token_file, "w") as f:
            json.dump(token_data, f)

    @property
    def service(self):
        """Get the YouTube API service."""
        if self._service is None:
            creds = self._get_credentials()
            self._service = build("youtube", "v3", credentials=creds)
        return self._service

    def upload(
        self,
        video_path: str,
        title: str,
        description: str,
        tags: list[str],
        thumbnail_path: Optional[str] = None,
        category_id: Optional[str] = None,
    ) -> dict:
        """Upload a video to YouTube as an unlisted draft.

        Args:
            video_path: Local path to the .mp4 file
            title: Video title
            description: Video description (SEO-optimized)
            tags: List of tags
            thumbnail_path: Optional local path to thumbnail image
            category_id: YouTube category ID (default: Education)

        Returns:
            dict with keys: video_id, video_url

        Raises:
            Exception on upload failure
        """
        body = {
            "snippet": {
                "title": title,
                "description": description,
                "tags": tags,
                "categoryId": category_id or self.category_id,
            },
            "status": {
                "privacyStatus": "unlisted",
                "selfDeclaredMadeForKids": False,
            },
        }

        media = MediaFileUpload(
            video_path,
            mimetype="video/mp4",
            resumable=True,
            chunksize=10 * 1024 * 1024,  # 10 MB chunks
        )

        print(f"    Uploading to YouTube: {title}")

        request = self.service.videos().insert(
            part="snippet,status",
            body=body,
            media_body=media,
        )

        response = None
        while response is None:
            status, response = request.next_chunk()
            if status:
                pct = int(status.progress() * 100)
                print(f"    Upload progress: {pct}%")

        video_id = response["id"]
        video_url = f"https://www.youtube.com/watch?v={video_id}"
        print(f"    Uploaded: {video_url}")

        # Set thumbnail if provided
        if thumbnail_path and os.path.exists(thumbnail_path):
            try:
                self._set_thumbnail(video_id, thumbnail_path)
            except Exception as e:
                print(f"    Warning: thumbnail upload failed: {e}")

        return {
            "video_id": video_id,
            "video_url": video_url,
        }

    def _set_thumbnail(self, video_id: str, thumbnail_path: str):
        """Set custom thumbnail for a YouTube video."""
        media = MediaFileUpload(thumbnail_path, mimetype="image/png")
        self.service.thumbnails().set(
            videoId=video_id,
            media_body=media,
        ).execute()
        print(f"    Thumbnail set for {video_id}")

    def upload_from_drive(
        self,
        google_client,
        airtable_client,
        idea: dict,
    ) -> dict:
        """Full upload flow: download from Drive, upload to YouTube, update Airtable.

        Args:
            google_client: GoogleClient instance for downloading from Drive
            airtable_client: AirtableClient instance for reading/updating fields
            idea: Airtable idea record dict

        Returns:
            dict with video_id, video_url on success
            dict with error key on failure
        """
        record_id = idea["id"]
        title = idea.get("Video Title", "Untitled")
        description = idea.get("SEO Description", "")
        tags_str = idea.get("SEO Tags", "")
        tags = [t.strip() for t in tags_str.split(",") if t.strip()] if tags_str else []

        # Get the final video from Drive
        final_video_url = idea.get("Final Video URL") or idea.get("Final Video")
        if not final_video_url:
            return {"error": "No Final Video URL in Airtable record"}

        # Extract Drive file ID
        import re

        file_id = None
        patterns = [
            r"/file/d/([a-zA-Z0-9_-]+)",
            r"[?&]id=([a-zA-Z0-9_-]+)",
        ]
        for pattern in patterns:
            match = re.search(pattern, final_video_url)
            if match:
                file_id = match.group(1)
                break

        if not file_id:
            return {"error": f"Cannot extract Drive file ID from: {final_video_url}"}

        # Mark as uploading
        airtable_client.update_idea_field(record_id, "Upload Status", "uploading")

        # Download to temp file
        tmp_dir = tempfile.mkdtemp(prefix="yt_upload_")
        safe_title = re.sub(r'[^\w\s-]', '', title)
        safe_title = re.sub(r'[-\s]+', '_', safe_title)[:50]
        local_video = os.path.join(tmp_dir, f"{safe_title}.mp4")

        try:
            print(f"    Downloading from Drive: {file_id}")
            google_client.download_file_to_local(file_id, local_video)
            file_size_mb = os.path.getsize(local_video) / (1024 * 1024)
            print(f"    Downloaded: {file_size_mb:.0f} MB")
        except Exception as e:
            airtable_client.update_idea_field(record_id, "Upload Status", "failed")
            self._cleanup(local_video, tmp_dir)
            return {"error": f"Drive download failed: {e}"}

        # Download thumbnail if available
        thumbnail_path = None
        thumbnail_url = idea.get("Thumbnail")
        if thumbnail_url:
            # Handle Airtable attachment format
            if isinstance(thumbnail_url, list) and thumbnail_url:
                thumbnail_url = thumbnail_url[0].get("url", "")
            if thumbnail_url:
                try:
                    import httpx

                    local_thumb = os.path.join(tmp_dir, "thumbnail.png")
                    resp = httpx.get(thumbnail_url, timeout=30.0, follow_redirects=True)
                    resp.raise_for_status()
                    with open(local_thumb, "wb") as f:
                        f.write(resp.content)
                    thumbnail_path = local_thumb
                except Exception as e:
                    print(f"    Warning: thumbnail download failed: {e}")

        # Upload to YouTube
        try:
            result = self.upload(
                video_path=local_video,
                title=title,
                description=description,
                tags=tags,
                thumbnail_path=thumbnail_path,
            )
        except Exception as e:
            airtable_client.update_idea_field(record_id, "Upload Status", "failed")
            self._cleanup(local_video, tmp_dir)
            return {"error": f"YouTube upload failed: {e}"}

        # Update Airtable with YouTube info
        airtable_client.update_idea_fields(record_id, {
            "YouTube Video ID": result["video_id"],
            "YouTube URL": result["video_url"],
            "Upload Status": "uploaded",
        })

        # Cleanup temp files
        self._cleanup(local_video, tmp_dir)

        return result

    def _cleanup(self, video_path: str, tmp_dir: str):
        """Remove temp files to save VPS disk space."""
        try:
            if os.path.exists(video_path):
                os.remove(video_path)
            # Remove thumbnail if present
            thumb_path = os.path.join(tmp_dir, "thumbnail.png")
            if os.path.exists(thumb_path):
                os.remove(thumb_path)
            if os.path.exists(tmp_dir):
                os.rmdir(tmp_dir)
        except Exception:
            pass  # Best effort cleanup
